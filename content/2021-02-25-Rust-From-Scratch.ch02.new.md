+++
title = "Rust From Scratch chap.02 | Rust 中的表达式（expressions）与语句（statements）"
draft = true
[taxonomies]
tags = ["rust"]
categories = ["Rust From Scratch"]
+++


# 1.Rust 中语句（statements）的四种类型

- 声明语句

- 流程控制语句

- 表达式语句

- 宏语句

## 三个关键元素

- 属性，类似于 #![...]

- 分号，行分隔符

- 花括号，块分隔符

## 求值规则

- 分号表达式返回值是永远为自身的单元（unit）类型。

- 分号表达式只有在块表达式最后一行才会进行求值，其他时候只作为『连接符』存在。

- 块表达式只对其最后一行表达式进行求值。


# 2. Rust 编译期计算

## 什么是编译期计算

即编译期函数计算求值。

Rust 编译器计算支持：常量函数和常量泛型

Rust 支持两种方式：

- 过程宏 + Build脚本(build.rs)

- CTFE (Compile-Time function Execution)

    - 常量函数（const fn），可支持递归。
    - 常量泛型（const generic）

### 常量上下文（const context）包含：

1. 常量值初始化位置

2. 静态数组的长度表达式，[T; N]

3. 重复的长度表达式，类似于：[0; 10]

4. 静态变量、枚举判别式的初始化位置。

### 常量传播（const propagation）

常量传播和编译期计算是不同的：

- 常量传播是编译器的一种优化。

- 常量传播并不能改变程序的任何行为，并且对开发者是隐藏的。

- 编译期计算则是指编译时执行的代码，必须要知道其结果，才能继续编译。

```
conset X: u32 = 3 + 4; // CTFE 
let x: uew = 4 + 3; // 不是 CTFE，但可能会被常量传播优化，因为它不是常量上下文。
```

### 常量安全（const safe）

- Rust 大部分表达式都可用作常量表达式。

- 并不是所有常量表达式都可以用在常量上下文。

- 编译期求值必须得到一个确定性的结果。

### 常量上下文可接受的常量表达式

- const fn 函数

- 元组结构体

- 元组的值

### 编译期计算如何实现

编译过程中 MIR （中级中间语言）阶段使用 MIRI（编译器内置MIR解释器）执行计算。

> 常量泛型会依赖泛型的具体实现。

